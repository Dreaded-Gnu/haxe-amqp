package amqp.helper.protocol;

import haxe.Json;
import haxe.Int64;
import format.tools.BitsInput;
import format.tools.BitsOutput;
import amqp.Codec;
import amqp.helper.Bytes;
import amqp.helper.BytesInput;
import amqp.helper.BytesOutput;

// This file was autogenerated by spec/GenerateDefinition.hx - Do not modify

class EncoderDecoderInfo {
  private static var SCRATCH:BytesOutput = new BytesOutput();
  public static inline var BasicConsumeOk:Int = 3932181;
  public static var methodInfoBasicConsumeOk:Dynamic = Json.parse('{"classId":60,"name":"BasicConsumeOk","methodId":21,"id":3932181,"args":[{"name":"consumerTag","def":null,"type":"shortstr"}]}');
  public static inline var BasicCancel:Int = 3932190;
  public static var methodInfoBasicCancel:Dynamic = Json.parse('{"classId":60,"name":"BasicCancel","methodId":30,"id":3932190,"args":[{"name":"consumerTag","def":null,"type":"shortstr"},{"name":"nowait","def":false,"type":"bit"}]}');
  public static inline var BasicRecover:Int = 3932270;
  public static var methodInfoBasicRecover:Dynamic = Json.parse('{"classId":60,"name":"BasicRecover","methodId":110,"id":3932270,"args":[{"name":"requeue","def":false,"type":"bit"}]}');
  public static inline var ExchangeUnbind:Int = 2621480;
  public static var methodInfoExchangeUnbind:Dynamic = Json.parse('{"classId":40,"name":"ExchangeUnbind","methodId":40,"id":2621480,"args":[{"name":"ticket","def":0,"type":"short"},{"name":"destination","def":null,"type":"shortstr"},{"name":"source","def":null,"type":"shortstr"},{"name":"routingKey","def":"","type":"shortstr"},{"name":"nowait","def":false,"type":"bit"},{"name":"arguments","def":{},"type":"table"}]}');
  public static inline var TxCommit:Int = 5898260;
  public static var methodInfoTxCommit:Dynamic = Json.parse('{"classId":90,"name":"TxCommit","methodId":20,"id":5898260,"args":[]}');
  public static inline var BasicPublish:Int = 3932200;
  public static var methodInfoBasicPublish:Dynamic = Json.parse('{"classId":60,"name":"BasicPublish","methodId":40,"id":3932200,"args":[{"name":"ticket","def":0,"type":"short"},{"name":"exchange","def":"","type":"shortstr"},{"name":"routingKey","def":"","type":"shortstr"},{"name":"mandatory","def":false,"type":"bit"},{"name":"immediate","def":false,"type":"bit"}]}');
  public static inline var QueuePurgeOk:Int = 3276831;
  public static var methodInfoQueuePurgeOk:Dynamic = Json.parse('{"classId":50,"name":"QueuePurgeOk","methodId":31,"id":3276831,"args":[{"name":"messageCount","def":null,"type":"long"}]}');
  public static inline var QueuePurge:Int = 3276830;
  public static var methodInfoQueuePurge:Dynamic = Json.parse('{"classId":50,"name":"QueuePurge","methodId":30,"id":3276830,"args":[{"name":"ticket","def":0,"type":"short"},{"name":"queue","def":"","type":"shortstr"},{"name":"nowait","def":false,"type":"bit"}]}');
  public static inline var TxCommitOk:Int = 5898261;
  public static var methodInfoTxCommitOk:Dynamic = Json.parse('{"classId":90,"name":"TxCommitOk","methodId":21,"id":5898261,"args":[]}');
  public static inline var AccessRequestOk:Int = 1966091;
  public static var methodInfoAccessRequestOk:Dynamic = Json.parse('{"classId":30,"name":"AccessRequestOk","methodId":11,"id":1966091,"args":[{"name":"ticket","def":1,"type":"short"}]}');
  public static inline var ExchangeUnbindOk:Int = 2621491;
  public static var methodInfoExchangeUnbindOk:Dynamic = Json.parse('{"classId":40,"name":"ExchangeUnbindOk","methodId":51,"id":2621491,"args":[]}');
  public static inline var ChannelFlow:Int = 1310740;
  public static var methodInfoChannelFlow:Dynamic = Json.parse('{"classId":20,"name":"ChannelFlow","methodId":20,"id":1310740,"args":[{"name":"active","def":null,"type":"bit"}]}');
  public static inline var ConnectionTuneOk:Int = 655391;
  public static var methodInfoConnectionTuneOk:Dynamic = Json.parse('{"classId":10,"name":"ConnectionTuneOk","methodId":31,"id":655391,"args":[{"name":"channelMax","def":0,"type":"short"},{"name":"frameMax","def":0,"type":"long"},{"name":"heartbeat","def":0,"type":"short"}]}');
  public static inline var TxRollbackOk:Int = 5898271;
  public static var methodInfoTxRollbackOk:Dynamic = Json.parse('{"classId":90,"name":"TxRollbackOk","methodId":31,"id":5898271,"args":[]}');
  public static inline var ConnectionSecure:Int = 655380;
  public static var methodInfoConnectionSecure:Dynamic = Json.parse('{"classId":10,"name":"ConnectionSecure","methodId":20,"id":655380,"args":[{"name":"challenge","def":null,"type":"longstr"}]}');
  public static inline var BasicRecoverOk:Int = 3932271;
  public static var methodInfoBasicRecoverOk:Dynamic = Json.parse('{"classId":60,"name":"BasicRecoverOk","methodId":111,"id":3932271,"args":[]}');
  public static inline var ExchangeBindOk:Int = 2621471;
  public static var methodInfoExchangeBindOk:Dynamic = Json.parse('{"classId":40,"name":"ExchangeBindOk","methodId":31,"id":2621471,"args":[]}');
  public static inline var TxSelectOk:Int = 5898251;
  public static var methodInfoTxSelectOk:Dynamic = Json.parse('{"classId":90,"name":"TxSelectOk","methodId":11,"id":5898251,"args":[]}');
  public static inline var ConnectionUnblocked:Int = 655421;
  public static var methodInfoConnectionUnblocked:Dynamic = Json.parse('{"classId":10,"name":"ConnectionUnblocked","methodId":61,"id":655421,"args":[]}');
  public static inline var BasicRecoverAsync:Int = 3932260;
  public static var methodInfoBasicRecoverAsync:Dynamic = Json.parse('{"classId":60,"name":"BasicRecoverAsync","methodId":100,"id":3932260,"args":[{"name":"requeue","def":false,"type":"bit"}]}');
  public static inline var ExchangeBind:Int = 2621470;
  public static var methodInfoExchangeBind:Dynamic = Json.parse('{"classId":40,"name":"ExchangeBind","methodId":30,"id":2621470,"args":[{"name":"ticket","def":0,"type":"short"},{"name":"destination","def":null,"type":"shortstr"},{"name":"source","def":null,"type":"shortstr"},{"name":"routingKey","def":"","type":"shortstr"},{"name":"nowait","def":false,"type":"bit"},{"name":"arguments","def":{},"type":"table"}]}');
  public static inline var ConfirmSelectOk:Int = 5570571;
  public static var methodInfoConfirmSelectOk:Dynamic = Json.parse('{"classId":85,"name":"ConfirmSelectOk","methodId":11,"id":5570571,"args":[]}');
  public static inline var BasicQosOk:Int = 3932171;
  public static var methodInfoBasicQosOk:Dynamic = Json.parse('{"classId":60,"name":"BasicQosOk","methodId":11,"id":3932171,"args":[]}');
  public static inline var ExchangeDelete:Int = 2621460;
  public static var methodInfoExchangeDelete:Dynamic = Json.parse('{"classId":40,"name":"ExchangeDelete","methodId":20,"id":2621460,"args":[{"name":"ticket","def":0,"type":"short"},{"name":"exchange","def":null,"type":"shortstr"},{"name":"ifUnused","def":false,"type":"bit"},{"name":"nowait","def":false,"type":"bit"}]}');
  public static inline var TxRollback:Int = 5898270;
  public static var methodInfoTxRollback:Dynamic = Json.parse('{"classId":90,"name":"TxRollback","methodId":30,"id":5898270,"args":[]}');
  public static inline var ConfirmSelect:Int = 5570570;
  public static var methodInfoConfirmSelect:Dynamic = Json.parse('{"classId":85,"name":"ConfirmSelect","methodId":10,"id":5570570,"args":[{"name":"nowait","def":false,"type":"bit"}]}');
  public static inline var ChannelFlowOk:Int = 1310741;
  public static var methodInfoChannelFlowOk:Dynamic = Json.parse('{"classId":20,"name":"ChannelFlowOk","methodId":21,"id":1310741,"args":[{"name":"active","def":null,"type":"bit"}]}');
  public static inline var BasicQos:Int = 3932170;
  public static var methodInfoBasicQos:Dynamic = Json.parse('{"classId":60,"name":"BasicQos","methodId":10,"id":3932170,"args":[{"name":"prefetchSize","def":0,"type":"long"},{"name":"prefetchCount","def":0,"type":"short"},{"name":"global","def":false,"type":"bit"}]}');
  public static inline var QueueDelete:Int = 3276840;
  public static var methodInfoQueueDelete:Dynamic = Json.parse('{"classId":50,"name":"QueueDelete","methodId":40,"id":3276840,"args":[{"name":"ticket","def":0,"type":"short"},{"name":"queue","def":"","type":"shortstr"},{"name":"ifUnused","def":false,"type":"bit"},{"name":"ifEmpty","def":false,"type":"bit"},{"name":"nowait","def":false,"type":"bit"}]}');
  public static inline var ChannelOpenOk:Int = 1310731;
  public static var methodInfoChannelOpenOk:Dynamic = Json.parse('{"classId":20,"name":"ChannelOpenOk","methodId":11,"id":1310731,"args":[{"name":"channelId","def":"","type":"longstr"}]}');
  public static inline var BasicCancelOk:Int = 3932191;
  public static var methodInfoBasicCancelOk:Dynamic = Json.parse('{"classId":60,"name":"BasicCancelOk","methodId":31,"id":3932191,"args":[{"name":"consumerTag","def":null,"type":"shortstr"}]}');
  public static inline var BasicReject:Int = 3932250;
  public static var methodInfoBasicReject:Dynamic = Json.parse('{"classId":60,"name":"BasicReject","methodId":90,"id":3932250,"args":[{"name":"deliveryTag","def":null,"type":"longlong"},{"name":"requeue","def":true,"type":"bit"}]}');
  public static inline var ConnectionCloseOk:Int = 655411;
  public static var methodInfoConnectionCloseOk:Dynamic = Json.parse('{"classId":10,"name":"ConnectionCloseOk","methodId":51,"id":655411,"args":[]}');
  public static inline var QueueDeleteOk:Int = 3276841;
  public static var methodInfoQueueDeleteOk:Dynamic = Json.parse('{"classId":50,"name":"QueueDeleteOk","methodId":41,"id":3276841,"args":[{"name":"messageCount","def":null,"type":"long"}]}');
  public static inline var ChannelClose:Int = 1310760;
  public static var methodInfoChannelClose:Dynamic = Json.parse('{"classId":20,"name":"ChannelClose","methodId":40,"id":1310760,"args":[{"name":"replyCode","def":null,"type":"short"},{"name":"replyText","def":"","type":"shortstr"},{"name":"classId","def":null,"type":"short"},{"name":"methodId","def":null,"type":"short"}]}');
  public static inline var BasicDeliver:Int = 3932220;
  public static var methodInfoBasicDeliver:Dynamic = Json.parse('{"classId":60,"name":"BasicDeliver","methodId":60,"id":3932220,"args":[{"name":"consumerTag","def":null,"type":"shortstr"},{"name":"deliveryTag","def":null,"type":"longlong"},{"name":"redelivered","def":false,"type":"bit"},{"name":"exchange","def":null,"type":"shortstr"},{"name":"routingKey","def":null,"type":"shortstr"}]}');
  public static inline var ChannelOpen:Int = 1310730;
  public static var methodInfoChannelOpen:Dynamic = Json.parse('{"classId":20,"name":"ChannelOpen","methodId":10,"id":1310730,"args":[{"name":"outOfBand","def":"","type":"shortstr"}]}');
  public static inline var BasicAck:Int = 3932240;
  public static var methodInfoBasicAck:Dynamic = Json.parse('{"classId":60,"name":"BasicAck","methodId":80,"id":3932240,"args":[{"name":"deliveryTag","def":0,"type":"longlong"},{"name":"multiple","def":false,"type":"bit"}]}');
  public static inline var ConnectionBlocked:Int = 655420;
  public static var methodInfoConnectionBlocked:Dynamic = Json.parse('{"classId":10,"name":"ConnectionBlocked","methodId":60,"id":655420,"args":[{"name":"reason","def":"","type":"shortstr"}]}');
  public static inline var AccessRequest:Int = 1966090;
  public static var methodInfoAccessRequest:Dynamic = Json.parse('{"classId":30,"name":"AccessRequest","methodId":10,"id":1966090,"args":[{"name":"realm","def":"/data","type":"shortstr"},{"name":"exclusive","def":false,"type":"bit"},{"name":"passive","def":true,"type":"bit"},{"name":"active","def":true,"type":"bit"},{"name":"write","def":true,"type":"bit"},{"name":"read","def":true,"type":"bit"}]}');
  public static inline var QueueDeclare:Int = 3276810;
  public static var methodInfoQueueDeclare:Dynamic = Json.parse('{"classId":50,"name":"QueueDeclare","methodId":10,"id":3276810,"args":[{"name":"ticket","def":0,"type":"short"},{"name":"queue","def":"","type":"shortstr"},{"name":"passive","def":false,"type":"bit"},{"name":"durable","def":false,"type":"bit"},{"name":"exclusive","def":false,"type":"bit"},{"name":"autoDelete","def":false,"type":"bit"},{"name":"nowait","def":false,"type":"bit"},{"name":"arguments","def":{},"type":"table"}]}');
  public static inline var QueueUnbind:Int = 3276850;
  public static var methodInfoQueueUnbind:Dynamic = Json.parse('{"classId":50,"name":"QueueUnbind","methodId":50,"id":3276850,"args":[{"name":"ticket","def":0,"type":"short"},{"name":"queue","def":"","type":"shortstr"},{"name":"exchange","def":null,"type":"shortstr"},{"name":"routingKey","def":"","type":"shortstr"},{"name":"arguments","def":{},"type":"table"}]}');
  public static inline var ChannelCloseOk:Int = 1310761;
  public static var methodInfoChannelCloseOk:Dynamic = Json.parse('{"classId":20,"name":"ChannelCloseOk","methodId":41,"id":1310761,"args":[]}');
  public static inline var BasicConsume:Int = 3932180;
  public static var methodInfoBasicConsume:Dynamic = Json.parse('{"classId":60,"name":"BasicConsume","methodId":20,"id":3932180,"args":[{"name":"ticket","def":0,"type":"short"},{"name":"queue","def":"","type":"shortstr"},{"name":"consumerTag","def":"","type":"shortstr"},{"name":"noLocal","def":false,"type":"bit"},{"name":"noAck","def":false,"type":"bit"},{"name":"exclusive","def":false,"type":"bit"},{"name":"nowait","def":false,"type":"bit"},{"name":"arguments","def":{},"type":"table"}]}');
  public static inline var QueueUnbindOk:Int = 3276851;
  public static var methodInfoQueueUnbindOk:Dynamic = Json.parse('{"classId":50,"name":"QueueUnbindOk","methodId":51,"id":3276851,"args":[]}');
  public static inline var BasicNack:Int = 3932280;
  public static var methodInfoBasicNack:Dynamic = Json.parse('{"classId":60,"name":"BasicNack","methodId":120,"id":3932280,"args":[{"name":"deliveryTag","def":0,"type":"longlong"},{"name":"multiple","def":false,"type":"bit"},{"name":"requeue","def":true,"type":"bit"}]}');
  public static inline var ConnectionOpenOk:Int = 655401;
  public static var methodInfoConnectionOpenOk:Dynamic = Json.parse('{"classId":10,"name":"ConnectionOpenOk","methodId":41,"id":655401,"args":[{"name":"knownHosts","def":"","type":"shortstr"}]}');
  public static inline var QueueBindOk:Int = 3276821;
  public static var methodInfoQueueBindOk:Dynamic = Json.parse('{"classId":50,"name":"QueueBindOk","methodId":21,"id":3276821,"args":[]}');
  public static inline var TxSelect:Int = 5898250;
  public static var methodInfoTxSelect:Dynamic = Json.parse('{"classId":90,"name":"TxSelect","methodId":10,"id":5898250,"args":[]}');
  public static inline var BasicReturn:Int = 3932210;
  public static var methodInfoBasicReturn:Dynamic = Json.parse('{"classId":60,"name":"BasicReturn","methodId":50,"id":3932210,"args":[{"name":"replyCode","def":null,"type":"short"},{"name":"replyText","def":"","type":"shortstr"},{"name":"exchange","def":null,"type":"shortstr"},{"name":"routingKey","def":null,"type":"shortstr"}]}');
  public static inline var ConnectionClose:Int = 655410;
  public static var methodInfoConnectionClose:Dynamic = Json.parse('{"classId":10,"name":"ConnectionClose","methodId":50,"id":655410,"args":[{"name":"replyCode","def":null,"type":"short"},{"name":"replyText","def":"","type":"shortstr"},{"name":"classId","def":null,"type":"short"},{"name":"methodId","def":null,"type":"short"}]}');
  public static inline var ConnectionTune:Int = 655390;
  public static var methodInfoConnectionTune:Dynamic = Json.parse('{"classId":10,"name":"ConnectionTune","methodId":30,"id":655390,"args":[{"name":"channelMax","def":0,"type":"short"},{"name":"frameMax","def":0,"type":"long"},{"name":"heartbeat","def":0,"type":"short"}]}');
  public static inline var ConnectionOpen:Int = 655400;
  public static var methodInfoConnectionOpen:Dynamic = Json.parse('{"classId":10,"name":"ConnectionOpen","methodId":40,"id":655400,"args":[{"name":"virtualHost","def":"/","type":"shortstr"},{"name":"capabilities","def":"","type":"shortstr"},{"name":"insist","def":false,"type":"bit"}]}');
  public static inline var BasicGet:Int = 3932230;
  public static var methodInfoBasicGet:Dynamic = Json.parse('{"classId":60,"name":"BasicGet","methodId":70,"id":3932230,"args":[{"name":"ticket","def":0,"type":"short"},{"name":"queue","def":"","type":"shortstr"},{"name":"noAck","def":false,"type":"bit"}]}');
  public static inline var BasicGetEmpty:Int = 3932232;
  public static var methodInfoBasicGetEmpty:Dynamic = Json.parse('{"classId":60,"name":"BasicGetEmpty","methodId":72,"id":3932232,"args":[{"name":"clusterId","def":"","type":"shortstr"}]}');
  public static inline var ExchangeDeleteOk:Int = 2621461;
  public static var methodInfoExchangeDeleteOk:Dynamic = Json.parse('{"classId":40,"name":"ExchangeDeleteOk","methodId":21,"id":2621461,"args":[]}');
  public static inline var ConnectionStartOk:Int = 655371;
  public static var methodInfoConnectionStartOk:Dynamic = Json.parse('{"classId":10,"name":"ConnectionStartOk","methodId":11,"id":655371,"args":[{"name":"clientProperties","def":null,"type":"table"},{"name":"mechanism","def":"PLAIN","type":"shortstr"},{"name":"response","def":null,"type":"longstr"},{"name":"locale","def":"en_US","type":"shortstr"}]}');
  public static inline var QueueDeclareOk:Int = 3276811;
  public static var methodInfoQueueDeclareOk:Dynamic = Json.parse('{"classId":50,"name":"QueueDeclareOk","methodId":11,"id":3276811,"args":[{"name":"queue","def":null,"type":"shortstr"},{"name":"messageCount","def":null,"type":"long"},{"name":"consumerCount","def":null,"type":"long"}]}');
  public static inline var ConnectionSecureOk:Int = 655381;
  public static var methodInfoConnectionSecureOk:Dynamic = Json.parse('{"classId":10,"name":"ConnectionSecureOk","methodId":21,"id":655381,"args":[{"name":"response","def":null,"type":"longstr"}]}');
  public static inline var ExchangeDeclareOk:Int = 2621451;
  public static var methodInfoExchangeDeclareOk:Dynamic = Json.parse('{"classId":40,"name":"ExchangeDeclareOk","methodId":11,"id":2621451,"args":[]}');
  public static inline var ExchangeDeclare:Int = 2621450;
  public static var methodInfoExchangeDeclare:Dynamic = Json.parse('{"classId":40,"name":"ExchangeDeclare","methodId":10,"id":2621450,"args":[{"name":"ticket","def":0,"type":"short"},{"name":"exchange","def":null,"type":"shortstr"},{"name":"type","def":"direct","type":"shortstr"},{"name":"passive","def":false,"type":"bit"},{"name":"durable","def":false,"type":"bit"},{"name":"autoDelete","def":false,"type":"bit"},{"name":"internal","def":false,"type":"bit"},{"name":"nowait","def":false,"type":"bit"},{"name":"arguments","def":{},"type":"table"}]}');
  public static inline var BasicGetOk:Int = 3932231;
  public static var methodInfoBasicGetOk:Dynamic = Json.parse('{"classId":60,"name":"BasicGetOk","methodId":71,"id":3932231,"args":[{"name":"deliveryTag","def":null,"type":"longlong"},{"name":"redelivered","def":false,"type":"bit"},{"name":"exchange","def":null,"type":"shortstr"},{"name":"routingKey","def":null,"type":"shortstr"},{"name":"messageCount","def":null,"type":"long"}]}');
  public static inline var QueueBind:Int = 3276820;
  public static var methodInfoQueueBind:Dynamic = Json.parse('{"classId":50,"name":"QueueBind","methodId":20,"id":3276820,"args":[{"name":"ticket","def":0,"type":"short"},{"name":"queue","def":"","type":"shortstr"},{"name":"exchange","def":null,"type":"shortstr"},{"name":"routingKey","def":"","type":"shortstr"},{"name":"nowait","def":false,"type":"bit"},{"name":"arguments","def":{},"type":"table"}]}');
  public static inline var ConnectionStart:Int = 655370;
  public static var methodInfoConnectionStart:Dynamic = Json.parse('{"classId":10,"name":"ConnectionStart","methodId":10,"id":655370,"args":[{"name":"versionMajor","def":0,"type":"octet"},{"name":"versionMinor","def":9,"type":"octet"},{"name":"serverProperties","def":null,"type":"table"},{"name":"mechanisms","def":"PLAIN","type":"longstr"},{"name":"locales","def":"en_US","type":"longstr"}]}');
  public static inline var BasicProperties:Int = 60;
  public static var propertiesInfoBasicProperties:Dynamic = Json.parse('{"classId":null,"name":"BasicProperties","methodId":null,"id":60,"args":[{"name":"contentType","def":null,"type":"shortstr"},{"name":"contentEncoding","def":null,"type":"shortstr"},{"name":"headers","def":null,"type":"table"},{"name":"deliveryMode","def":null,"type":"octet"},{"name":"priority","def":null,"type":"octet"},{"name":"correlationId","def":null,"type":"shortstr"},{"name":"replyTo","def":null,"type":"shortstr"},{"name":"expiration","def":null,"type":"shortstr"},{"name":"messageId","def":null,"type":"shortstr"},{"name":"timestamp","def":null,"type":"timestamp"},{"name":"type","def":null,"type":"shortstr"},{"name":"userId","def":null,"type":"shortstr"},{"name":"appId","def":null,"type":"shortstr"},{"name":"clusterId","def":null,"type":"shortstr"}]}');
  public static function decodeBasicConsumeOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {consumerTag: null,};
    buffer.bigEndian = true;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.consumerTag = val;
    return fields;
  }

  public static function encodeBasicConsumeOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.consumerTag;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"consumerTag\"");
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"consumerTag\" is the wrong type; must be a string (up to 255 chars)");
    }
    var consumerTag_len:Int = cast(val, String).length;
    varyingSize += consumerTag_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(13 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3932181);
    val = fields.consumerTag;
    if (val == null) val = null;
    output.writeByte(consumerTag_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeBasicCancel(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {consumerTag: null,nowait: null,};
    buffer.bigEndian = true;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.consumerTag = val;
    val = bits.readBit();
    fields.nowait = val;
    return fields;
  }

  public static function encodeBasicCancel(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.consumerTag;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"consumerTag\"");
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"consumerTag\" is the wrong type; must be a string (up to 255 chars)");
    }
    var consumerTag_len:Int = cast(val, String).length;
    varyingSize += consumerTag_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(14 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3932190);
    val = fields.consumerTag;
    if (val == null) val = null;
    output.writeByte(consumerTag_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.nowait;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"nowait\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    output.writeByte(bits);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeBasicRecover(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {requeue: null,};
    buffer.bigEndian = true;
    val = bits.readBit();
    fields.requeue = val;
    return fields;
  }

  public static function encodeBasicRecover(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(13 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3932270);
    val = fields.requeue;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"requeue\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    output.writeByte(bits);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeExchangeUnbind(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {ticket: null,destination: null,source: null,routingKey: null,nowait: null,arguments: null,};
    buffer.bigEndian = true;
    val = buffer.readInt16();
    fields.ticket = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.destination = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.source = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.routingKey = val;
    val = bits.readBit();
    fields.nowait = val;
    // read full byte before starting with next
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    len = buffer.readInt32();
    b = Bytes.alloc(len);
    buffer.readBytes(b, 0, len);
    val = Codec.DecodeFields(b);
    fields.arguments = val;
    return fields;
  }

  public static function encodeExchangeUnbind(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.destination;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"destination\"");
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"destination\" is the wrong type; must be a string (up to 255 chars)");
    }
    var destination_len:Int = cast(val, String).length;
    varyingSize += destination_len;
    val = fields.source;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"source\"");
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"source\" is the wrong type; must be a string (up to 255 chars)");
    }
    var source_len:Int = cast(val, String).length;
    varyingSize += source_len;
    val = fields.routingKey;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"routingKey\" is the wrong type; must be a string (up to 255 chars)");
    }
    var routingKey_len:Int = cast(val, String).length;
    varyingSize += routingKey_len;
    val = fields.arguments;
    if (val == null) {
      val = {};
    } else if (!(Std.isOfType(val, Dynamic))) {
      throw new haxe.Exception("Field \"arguments\" is the wrong type; must be a Dynamic");
    }
    // ensure big endian and flush previous content
    SCRATCH.bigEndian = true;
    SCRATCH.flush();
    // encode table
    var arguments_encoded:Bytes = Codec.EncodeTable(SCRATCH, val);
    varyingSize += arguments_encoded.length;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(18 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(2621480);
    val = fields.ticket;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"ticket\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.destination;
    if (val == null) val = null;
    output.writeByte(destination_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.source;
    if (val == null) val = null;
    output.writeByte(source_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.routingKey;
    if (val == null) val = "";
    output.writeByte(routingKey_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.nowait;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"nowait\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    output.writeByte(bits);
    output.writeBytes(arguments_encoded, 0, arguments_encoded.length);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeTxCommit(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {};
    buffer.bigEndian = true;
    return fields;
  }

  public static function encodeTxCommit(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(12 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(5898260);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeBasicPublish(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {ticket: null,exchange: null,routingKey: null,mandatory: null,immediate: null,};
    buffer.bigEndian = true;
    val = buffer.readInt16();
    fields.ticket = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.exchange = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.routingKey = val;
    val = bits.readBit();
    fields.mandatory = val;
    val = bits.readBit();
    fields.immediate = val;
    return fields;
  }

  public static function encodeBasicPublish(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.exchange;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"exchange\" is the wrong type; must be a string (up to 255 chars)");
    }
    var exchange_len:Int = cast(val, String).length;
    varyingSize += exchange_len;
    val = fields.routingKey;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"routingKey\" is the wrong type; must be a string (up to 255 chars)");
    }
    var routingKey_len:Int = cast(val, String).length;
    varyingSize += routingKey_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(17 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3932200);
    val = fields.ticket;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"ticket\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.exchange;
    if (val == null) val = "";
    output.writeByte(exchange_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.routingKey;
    if (val == null) val = "";
    output.writeByte(routingKey_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.mandatory;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"mandatory\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    val = fields.immediate;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"immediate\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 2;
    }
    output.writeByte(bits);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeQueuePurgeOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {messageCount: null,};
    buffer.bigEndian = true;
    val = buffer.readInt32();
    fields.messageCount = val;
    return fields;
  }

  public static function encodeQueuePurgeOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(16 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3276831);
    val = fields.messageCount;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"messageCount\"");
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"messageCount\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt32(val);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeQueuePurge(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {ticket: null,queue: null,nowait: null,};
    buffer.bigEndian = true;
    val = buffer.readInt16();
    fields.ticket = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.queue = val;
    val = bits.readBit();
    fields.nowait = val;
    return fields;
  }

  public static function encodeQueuePurge(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.queue;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"queue\" is the wrong type; must be a string (up to 255 chars)");
    }
    var queue_len:Int = cast(val, String).length;
    varyingSize += queue_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(16 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3276830);
    val = fields.ticket;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"ticket\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.queue;
    if (val == null) val = "";
    output.writeByte(queue_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.nowait;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"nowait\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    output.writeByte(bits);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeTxCommitOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {};
    buffer.bigEndian = true;
    return fields;
  }

  public static function encodeTxCommitOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(12 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(5898261);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeAccessRequestOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {ticket: null,};
    buffer.bigEndian = true;
    val = buffer.readInt16();
    fields.ticket = val;
    return fields;
  }

  public static function encodeAccessRequestOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(14 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(1966091);
    val = fields.ticket;
    if (val == null) {
      val = 1;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"ticket\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeExchangeUnbindOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {};
    buffer.bigEndian = true;
    return fields;
  }

  public static function encodeExchangeUnbindOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(12 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(2621491);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeChannelFlow(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {active: null,};
    buffer.bigEndian = true;
    val = bits.readBit();
    fields.active = val;
    return fields;
  }

  public static function encodeChannelFlow(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(13 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(1310740);
    val = fields.active;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"active\"");
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"active\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    output.writeByte(bits);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeConnectionTuneOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {channelMax: null,frameMax: null,heartbeat: null,};
    buffer.bigEndian = true;
    val = buffer.readInt16();
    fields.channelMax = val;
    val = buffer.readInt32();
    fields.frameMax = val;
    val = buffer.readInt16();
    fields.heartbeat = val;
    return fields;
  }

  public static function encodeConnectionTuneOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(20 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(655391);
    val = fields.channelMax;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"channelMax\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.frameMax;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"frameMax\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt32(val);
    val = fields.heartbeat;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"heartbeat\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeTxRollbackOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {};
    buffer.bigEndian = true;
    return fields;
  }

  public static function encodeTxRollbackOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(12 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(5898271);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeConnectionSecure(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {challenge: null,};
    buffer.bigEndian = true;
    len = buffer.readInt32();
    val = buffer.readString(len);
    fields.challenge = val;
    return fields;
  }

  public static function encodeConnectionSecure(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.challenge;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"challenge\"");
    } else if (!(Std.isOfType(val, String))) {
      throw new haxe.Exception("Field \"challenge\" is the wrong type; must be a String");
    }
    varyingSize += val.length;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(16 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(655380);
    val = fields.challenge;
    if (val == null) val = null;
    len = cast(val, String).length;
    output.writeInt32(len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeBasicRecoverOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {};
    buffer.bigEndian = true;
    return fields;
  }

  public static function encodeBasicRecoverOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(12 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3932271);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeExchangeBindOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {};
    buffer.bigEndian = true;
    return fields;
  }

  public static function encodeExchangeBindOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(12 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(2621471);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeTxSelectOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {};
    buffer.bigEndian = true;
    return fields;
  }

  public static function encodeTxSelectOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(12 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(5898251);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeConnectionUnblocked(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {};
    buffer.bigEndian = true;
    return fields;
  }

  public static function encodeConnectionUnblocked(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(12 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(655421);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeBasicRecoverAsync(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {requeue: null,};
    buffer.bigEndian = true;
    val = bits.readBit();
    fields.requeue = val;
    return fields;
  }

  public static function encodeBasicRecoverAsync(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(13 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3932260);
    val = fields.requeue;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"requeue\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    output.writeByte(bits);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeExchangeBind(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {ticket: null,destination: null,source: null,routingKey: null,nowait: null,arguments: null,};
    buffer.bigEndian = true;
    val = buffer.readInt16();
    fields.ticket = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.destination = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.source = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.routingKey = val;
    val = bits.readBit();
    fields.nowait = val;
    // read full byte before starting with next
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    len = buffer.readInt32();
    b = Bytes.alloc(len);
    buffer.readBytes(b, 0, len);
    val = Codec.DecodeFields(b);
    fields.arguments = val;
    return fields;
  }

  public static function encodeExchangeBind(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.destination;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"destination\"");
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"destination\" is the wrong type; must be a string (up to 255 chars)");
    }
    var destination_len:Int = cast(val, String).length;
    varyingSize += destination_len;
    val = fields.source;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"source\"");
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"source\" is the wrong type; must be a string (up to 255 chars)");
    }
    var source_len:Int = cast(val, String).length;
    varyingSize += source_len;
    val = fields.routingKey;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"routingKey\" is the wrong type; must be a string (up to 255 chars)");
    }
    var routingKey_len:Int = cast(val, String).length;
    varyingSize += routingKey_len;
    val = fields.arguments;
    if (val == null) {
      val = {};
    } else if (!(Std.isOfType(val, Dynamic))) {
      throw new haxe.Exception("Field \"arguments\" is the wrong type; must be a Dynamic");
    }
    // ensure big endian and flush previous content
    SCRATCH.bigEndian = true;
    SCRATCH.flush();
    // encode table
    var arguments_encoded:Bytes = Codec.EncodeTable(SCRATCH, val);
    varyingSize += arguments_encoded.length;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(18 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(2621470);
    val = fields.ticket;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"ticket\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.destination;
    if (val == null) val = null;
    output.writeByte(destination_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.source;
    if (val == null) val = null;
    output.writeByte(source_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.routingKey;
    if (val == null) val = "";
    output.writeByte(routingKey_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.nowait;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"nowait\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    output.writeByte(bits);
    output.writeBytes(arguments_encoded, 0, arguments_encoded.length);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeConfirmSelectOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {};
    buffer.bigEndian = true;
    return fields;
  }

  public static function encodeConfirmSelectOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(12 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(5570571);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeBasicQosOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {};
    buffer.bigEndian = true;
    return fields;
  }

  public static function encodeBasicQosOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(12 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3932171);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeExchangeDelete(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {ticket: null,exchange: null,ifUnused: null,nowait: null,};
    buffer.bigEndian = true;
    val = buffer.readInt16();
    fields.ticket = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.exchange = val;
    val = bits.readBit();
    fields.ifUnused = val;
    val = bits.readBit();
    fields.nowait = val;
    return fields;
  }

  public static function encodeExchangeDelete(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.exchange;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"exchange\"");
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"exchange\" is the wrong type; must be a string (up to 255 chars)");
    }
    var exchange_len:Int = cast(val, String).length;
    varyingSize += exchange_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(16 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(2621460);
    val = fields.ticket;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"ticket\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.exchange;
    if (val == null) val = null;
    output.writeByte(exchange_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.ifUnused;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"ifUnused\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    val = fields.nowait;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"nowait\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 2;
    }
    output.writeByte(bits);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeTxRollback(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {};
    buffer.bigEndian = true;
    return fields;
  }

  public static function encodeTxRollback(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(12 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(5898270);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeConfirmSelect(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {nowait: null,};
    buffer.bigEndian = true;
    val = bits.readBit();
    fields.nowait = val;
    return fields;
  }

  public static function encodeConfirmSelect(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(13 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(5570570);
    val = fields.nowait;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"nowait\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    output.writeByte(bits);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeChannelFlowOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {active: null,};
    buffer.bigEndian = true;
    val = bits.readBit();
    fields.active = val;
    return fields;
  }

  public static function encodeChannelFlowOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(13 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(1310741);
    val = fields.active;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"active\"");
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"active\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    output.writeByte(bits);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeBasicQos(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {prefetchSize: null,prefetchCount: null,global: null,};
    buffer.bigEndian = true;
    val = buffer.readInt32();
    fields.prefetchSize = val;
    val = buffer.readInt16();
    fields.prefetchCount = val;
    val = bits.readBit();
    fields.global = val;
    return fields;
  }

  public static function encodeBasicQos(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(19 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3932170);
    val = fields.prefetchSize;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"prefetchSize\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt32(val);
    val = fields.prefetchCount;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"prefetchCount\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.global;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"global\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    output.writeByte(bits);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeQueueDelete(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {ticket: null,queue: null,ifUnused: null,ifEmpty: null,nowait: null,};
    buffer.bigEndian = true;
    val = buffer.readInt16();
    fields.ticket = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.queue = val;
    val = bits.readBit();
    fields.ifUnused = val;
    val = bits.readBit();
    fields.ifEmpty = val;
    val = bits.readBit();
    fields.nowait = val;
    return fields;
  }

  public static function encodeQueueDelete(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.queue;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"queue\" is the wrong type; must be a string (up to 255 chars)");
    }
    var queue_len:Int = cast(val, String).length;
    varyingSize += queue_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(16 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3276840);
    val = fields.ticket;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"ticket\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.queue;
    if (val == null) val = "";
    output.writeByte(queue_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.ifUnused;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"ifUnused\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    val = fields.ifEmpty;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"ifEmpty\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 2;
    }
    val = fields.nowait;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"nowait\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 4;
    }
    output.writeByte(bits);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeChannelOpenOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {channelId: null,};
    buffer.bigEndian = true;
    len = buffer.readInt32();
    val = buffer.readString(len);
    fields.channelId = val;
    return fields;
  }

  public static function encodeChannelOpenOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.channelId;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String))) {
      throw new haxe.Exception("Field \"channelId\" is the wrong type; must be a String");
    }
    varyingSize += val.length;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(16 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(1310731);
    val = fields.channelId;
    if (val == null) val = "";
    len = cast(val, String).length;
    output.writeInt32(len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeBasicCancelOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {consumerTag: null,};
    buffer.bigEndian = true;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.consumerTag = val;
    return fields;
  }

  public static function encodeBasicCancelOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.consumerTag;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"consumerTag\"");
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"consumerTag\" is the wrong type; must be a string (up to 255 chars)");
    }
    var consumerTag_len:Int = cast(val, String).length;
    varyingSize += consumerTag_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(13 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3932191);
    val = fields.consumerTag;
    if (val == null) val = null;
    output.writeByte(consumerTag_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeBasicReject(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {deliveryTag: null,requeue: null,};
    buffer.bigEndian = true;
    val = buffer.readInt64();
    fields.deliveryTag = val;
    val = bits.readBit();
    fields.requeue = val;
    return fields;
  }

  public static function encodeBasicReject(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(13 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3932250);
    val = fields.deliveryTag;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"deliveryTag\"");
    } else if (!(Int64.isInt64(val))) {
      throw new haxe.Exception("Field \"deliveryTag\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt64(val);
    val = fields.requeue;
    if (val == null) {
      val = true;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"requeue\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    output.writeByte(bits);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeConnectionCloseOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {};
    buffer.bigEndian = true;
    return fields;
  }

  public static function encodeConnectionCloseOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(12 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(655411);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeQueueDeleteOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {messageCount: null,};
    buffer.bigEndian = true;
    val = buffer.readInt32();
    fields.messageCount = val;
    return fields;
  }

  public static function encodeQueueDeleteOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(16 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3276841);
    val = fields.messageCount;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"messageCount\"");
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"messageCount\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt32(val);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeChannelClose(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {replyCode: null,replyText: null,classId: null,methodId: null,};
    buffer.bigEndian = true;
    val = buffer.readInt16();
    fields.replyCode = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.replyText = val;
    val = buffer.readInt16();
    fields.classId = val;
    val = buffer.readInt16();
    fields.methodId = val;
    return fields;
  }

  public static function encodeChannelClose(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.replyText;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"replyText\" is the wrong type; must be a string (up to 255 chars)");
    }
    var replyText_len:Int = cast(val, String).length;
    varyingSize += replyText_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(19 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(1310760);
    val = fields.replyCode;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"replyCode\"");
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"replyCode\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.replyText;
    if (val == null) val = "";
    output.writeByte(replyText_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.classId;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"classId\"");
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"classId\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.methodId;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"methodId\"");
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"methodId\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeBasicDeliver(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {consumerTag: null,deliveryTag: null,redelivered: null,exchange: null,routingKey: null,};
    buffer.bigEndian = true;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.consumerTag = val;
    val = buffer.readInt64();
    fields.deliveryTag = val;
    val = bits.readBit();
    fields.redelivered = val;
    // read full byte before starting with next
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.exchange = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.routingKey = val;
    return fields;
  }

  public static function encodeBasicDeliver(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.consumerTag;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"consumerTag\"");
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"consumerTag\" is the wrong type; must be a string (up to 255 chars)");
    }
    var consumerTag_len:Int = cast(val, String).length;
    varyingSize += consumerTag_len;
    val = fields.exchange;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"exchange\"");
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"exchange\" is the wrong type; must be a string (up to 255 chars)");
    }
    var exchange_len:Int = cast(val, String).length;
    varyingSize += exchange_len;
    val = fields.routingKey;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"routingKey\"");
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"routingKey\" is the wrong type; must be a string (up to 255 chars)");
    }
    var routingKey_len:Int = cast(val, String).length;
    varyingSize += routingKey_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(16 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3932220);
    val = fields.consumerTag;
    if (val == null) val = null;
    output.writeByte(consumerTag_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.deliveryTag;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"deliveryTag\"");
    } else if (!(Int64.isInt64(val))) {
      throw new haxe.Exception("Field \"deliveryTag\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt64(val);
    val = fields.redelivered;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"redelivered\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    output.writeByte(bits);
    val = fields.exchange;
    if (val == null) val = null;
    output.writeByte(exchange_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.routingKey;
    if (val == null) val = null;
    output.writeByte(routingKey_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeChannelOpen(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {outOfBand: null,};
    buffer.bigEndian = true;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.outOfBand = val;
    return fields;
  }

  public static function encodeChannelOpen(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.outOfBand;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"outOfBand\" is the wrong type; must be a string (up to 255 chars)");
    }
    var outOfBand_len:Int = cast(val, String).length;
    varyingSize += outOfBand_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(13 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(1310730);
    val = fields.outOfBand;
    if (val == null) val = "";
    output.writeByte(outOfBand_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeBasicAck(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {deliveryTag: null,multiple: null,};
    buffer.bigEndian = true;
    val = buffer.readInt64();
    fields.deliveryTag = val;
    val = bits.readBit();
    fields.multiple = val;
    return fields;
  }

  public static function encodeBasicAck(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(13 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3932240);
    val = fields.deliveryTag;
    if (val == null) {
      val = 0;
    } else if (!(Int64.isInt64(val))) {
      throw new haxe.Exception("Field \"deliveryTag\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt64(val);
    val = fields.multiple;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"multiple\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    output.writeByte(bits);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeConnectionBlocked(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {reason: null,};
    buffer.bigEndian = true;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.reason = val;
    return fields;
  }

  public static function encodeConnectionBlocked(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.reason;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"reason\" is the wrong type; must be a string (up to 255 chars)");
    }
    var reason_len:Int = cast(val, String).length;
    varyingSize += reason_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(13 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(655420);
    val = fields.reason;
    if (val == null) val = "";
    output.writeByte(reason_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeAccessRequest(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {realm: null,exclusive: null,passive: null,active: null,write: null,read: null,};
    buffer.bigEndian = true;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.realm = val;
    val = bits.readBit();
    fields.exclusive = val;
    val = bits.readBit();
    fields.passive = val;
    val = bits.readBit();
    fields.active = val;
    val = bits.readBit();
    fields.write = val;
    val = bits.readBit();
    fields.read = val;
    return fields;
  }

  public static function encodeAccessRequest(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.realm;
    if (val == null) {
      val = "/data";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"realm\" is the wrong type; must be a string (up to 255 chars)");
    }
    var realm_len:Int = cast(val, String).length;
    varyingSize += realm_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(14 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(1966090);
    val = fields.realm;
    if (val == null) val = "/data";
    output.writeByte(realm_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.exclusive;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"exclusive\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    val = fields.passive;
    if (val == null) {
      val = true;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"passive\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 2;
    }
    val = fields.active;
    if (val == null) {
      val = true;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"active\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 4;
    }
    val = fields.write;
    if (val == null) {
      val = true;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"write\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 8;
    }
    val = fields.read;
    if (val == null) {
      val = true;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"read\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 16;
    }
    output.writeByte(bits);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeQueueDeclare(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {ticket: null,queue: null,passive: null,durable: null,exclusive: null,autoDelete: null,nowait: null,arguments: null,};
    buffer.bigEndian = true;
    val = buffer.readInt16();
    fields.ticket = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.queue = val;
    val = bits.readBit();
    fields.passive = val;
    val = bits.readBit();
    fields.durable = val;
    val = bits.readBit();
    fields.exclusive = val;
    val = bits.readBit();
    fields.autoDelete = val;
    val = bits.readBit();
    fields.nowait = val;
    // read full byte before starting with next
    bits.readBit();
    bits.readBit();
    bits.readBit();
    len = buffer.readInt32();
    b = Bytes.alloc(len);
    buffer.readBytes(b, 0, len);
    val = Codec.DecodeFields(b);
    fields.arguments = val;
    return fields;
  }

  public static function encodeQueueDeclare(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.queue;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"queue\" is the wrong type; must be a string (up to 255 chars)");
    }
    var queue_len:Int = cast(val, String).length;
    varyingSize += queue_len;
    val = fields.arguments;
    if (val == null) {
      val = {};
    } else if (!(Std.isOfType(val, Dynamic))) {
      throw new haxe.Exception("Field \"arguments\" is the wrong type; must be a Dynamic");
    }
    // ensure big endian and flush previous content
    SCRATCH.bigEndian = true;
    SCRATCH.flush();
    // encode table
    var arguments_encoded:Bytes = Codec.EncodeTable(SCRATCH, val);
    varyingSize += arguments_encoded.length;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(16 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3276810);
    val = fields.ticket;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"ticket\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.queue;
    if (val == null) val = "";
    output.writeByte(queue_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.passive;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"passive\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    val = fields.durable;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"durable\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 2;
    }
    val = fields.exclusive;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"exclusive\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 4;
    }
    val = fields.autoDelete;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"autoDelete\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 8;
    }
    val = fields.nowait;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"nowait\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 16;
    }
    output.writeByte(bits);
    output.writeBytes(arguments_encoded, 0, arguments_encoded.length);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeQueueUnbind(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {ticket: null,queue: null,exchange: null,routingKey: null,arguments: null,};
    buffer.bigEndian = true;
    val = buffer.readInt16();
    fields.ticket = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.queue = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.exchange = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.routingKey = val;
    len = buffer.readInt32();
    b = Bytes.alloc(len);
    buffer.readBytes(b, 0, len);
    val = Codec.DecodeFields(b);
    fields.arguments = val;
    return fields;
  }

  public static function encodeQueueUnbind(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.queue;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"queue\" is the wrong type; must be a string (up to 255 chars)");
    }
    var queue_len:Int = cast(val, String).length;
    varyingSize += queue_len;
    val = fields.exchange;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"exchange\"");
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"exchange\" is the wrong type; must be a string (up to 255 chars)");
    }
    var exchange_len:Int = cast(val, String).length;
    varyingSize += exchange_len;
    val = fields.routingKey;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"routingKey\" is the wrong type; must be a string (up to 255 chars)");
    }
    var routingKey_len:Int = cast(val, String).length;
    varyingSize += routingKey_len;
    val = fields.arguments;
    if (val == null) {
      val = {};
    } else if (!(Std.isOfType(val, Dynamic))) {
      throw new haxe.Exception("Field \"arguments\" is the wrong type; must be a Dynamic");
    }
    // ensure big endian and flush previous content
    SCRATCH.bigEndian = true;
    SCRATCH.flush();
    // encode table
    var arguments_encoded:Bytes = Codec.EncodeTable(SCRATCH, val);
    varyingSize += arguments_encoded.length;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(17 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3276850);
    val = fields.ticket;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"ticket\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.queue;
    if (val == null) val = "";
    output.writeByte(queue_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.exchange;
    if (val == null) val = null;
    output.writeByte(exchange_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.routingKey;
    if (val == null) val = "";
    output.writeByte(routingKey_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    output.writeBytes(arguments_encoded, 0, arguments_encoded.length);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeChannelCloseOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {};
    buffer.bigEndian = true;
    return fields;
  }

  public static function encodeChannelCloseOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(12 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(1310761);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeBasicConsume(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {ticket: null,queue: null,consumerTag: null,noLocal: null,noAck: null,exclusive: null,nowait: null,arguments: null,};
    buffer.bigEndian = true;
    val = buffer.readInt16();
    fields.ticket = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.queue = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.consumerTag = val;
    val = bits.readBit();
    fields.noLocal = val;
    val = bits.readBit();
    fields.noAck = val;
    val = bits.readBit();
    fields.exclusive = val;
    val = bits.readBit();
    fields.nowait = val;
    // read full byte before starting with next
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    len = buffer.readInt32();
    b = Bytes.alloc(len);
    buffer.readBytes(b, 0, len);
    val = Codec.DecodeFields(b);
    fields.arguments = val;
    return fields;
  }

  public static function encodeBasicConsume(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.queue;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"queue\" is the wrong type; must be a string (up to 255 chars)");
    }
    var queue_len:Int = cast(val, String).length;
    varyingSize += queue_len;
    val = fields.consumerTag;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"consumerTag\" is the wrong type; must be a string (up to 255 chars)");
    }
    var consumerTag_len:Int = cast(val, String).length;
    varyingSize += consumerTag_len;
    val = fields.arguments;
    if (val == null) {
      val = {};
    } else if (!(Std.isOfType(val, Dynamic))) {
      throw new haxe.Exception("Field \"arguments\" is the wrong type; must be a Dynamic");
    }
    // ensure big endian and flush previous content
    SCRATCH.bigEndian = true;
    SCRATCH.flush();
    // encode table
    var arguments_encoded:Bytes = Codec.EncodeTable(SCRATCH, val);
    varyingSize += arguments_encoded.length;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(17 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3932180);
    val = fields.ticket;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"ticket\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.queue;
    if (val == null) val = "";
    output.writeByte(queue_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.consumerTag;
    if (val == null) val = "";
    output.writeByte(consumerTag_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.noLocal;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"noLocal\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    val = fields.noAck;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"noAck\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 2;
    }
    val = fields.exclusive;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"exclusive\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 4;
    }
    val = fields.nowait;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"nowait\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 8;
    }
    output.writeByte(bits);
    output.writeBytes(arguments_encoded, 0, arguments_encoded.length);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeQueueUnbindOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {};
    buffer.bigEndian = true;
    return fields;
  }

  public static function encodeQueueUnbindOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(12 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3276851);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeBasicNack(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {deliveryTag: null,multiple: null,requeue: null,};
    buffer.bigEndian = true;
    val = buffer.readInt64();
    fields.deliveryTag = val;
    val = bits.readBit();
    fields.multiple = val;
    val = bits.readBit();
    fields.requeue = val;
    return fields;
  }

  public static function encodeBasicNack(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(13 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3932280);
    val = fields.deliveryTag;
    if (val == null) {
      val = 0;
    } else if (!(Int64.isInt64(val))) {
      throw new haxe.Exception("Field \"deliveryTag\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt64(val);
    val = fields.multiple;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"multiple\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    val = fields.requeue;
    if (val == null) {
      val = true;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"requeue\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 2;
    }
    output.writeByte(bits);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeConnectionOpenOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {knownHosts: null,};
    buffer.bigEndian = true;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.knownHosts = val;
    return fields;
  }

  public static function encodeConnectionOpenOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.knownHosts;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"knownHosts\" is the wrong type; must be a string (up to 255 chars)");
    }
    var knownHosts_len:Int = cast(val, String).length;
    varyingSize += knownHosts_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(13 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(655401);
    val = fields.knownHosts;
    if (val == null) val = "";
    output.writeByte(knownHosts_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeQueueBindOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {};
    buffer.bigEndian = true;
    return fields;
  }

  public static function encodeQueueBindOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(12 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3276821);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeTxSelect(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {};
    buffer.bigEndian = true;
    return fields;
  }

  public static function encodeTxSelect(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(12 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(5898250);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeBasicReturn(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {replyCode: null,replyText: null,exchange: null,routingKey: null,};
    buffer.bigEndian = true;
    val = buffer.readInt16();
    fields.replyCode = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.replyText = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.exchange = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.routingKey = val;
    return fields;
  }

  public static function encodeBasicReturn(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.replyText;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"replyText\" is the wrong type; must be a string (up to 255 chars)");
    }
    var replyText_len:Int = cast(val, String).length;
    varyingSize += replyText_len;
    val = fields.exchange;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"exchange\"");
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"exchange\" is the wrong type; must be a string (up to 255 chars)");
    }
    var exchange_len:Int = cast(val, String).length;
    varyingSize += exchange_len;
    val = fields.routingKey;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"routingKey\"");
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"routingKey\" is the wrong type; must be a string (up to 255 chars)");
    }
    var routingKey_len:Int = cast(val, String).length;
    varyingSize += routingKey_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(17 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3932210);
    val = fields.replyCode;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"replyCode\"");
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"replyCode\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.replyText;
    if (val == null) val = "";
    output.writeByte(replyText_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.exchange;
    if (val == null) val = null;
    output.writeByte(exchange_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.routingKey;
    if (val == null) val = null;
    output.writeByte(routingKey_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeConnectionClose(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {replyCode: null,replyText: null,classId: null,methodId: null,};
    buffer.bigEndian = true;
    val = buffer.readInt16();
    fields.replyCode = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.replyText = val;
    val = buffer.readInt16();
    fields.classId = val;
    val = buffer.readInt16();
    fields.methodId = val;
    return fields;
  }

  public static function encodeConnectionClose(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.replyText;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"replyText\" is the wrong type; must be a string (up to 255 chars)");
    }
    var replyText_len:Int = cast(val, String).length;
    varyingSize += replyText_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(19 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(655410);
    val = fields.replyCode;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"replyCode\"");
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"replyCode\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.replyText;
    if (val == null) val = "";
    output.writeByte(replyText_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.classId;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"classId\"");
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"classId\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.methodId;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"methodId\"");
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"methodId\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeConnectionTune(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {channelMax: null,frameMax: null,heartbeat: null,};
    buffer.bigEndian = true;
    val = buffer.readInt16();
    fields.channelMax = val;
    val = buffer.readInt32();
    fields.frameMax = val;
    val = buffer.readInt16();
    fields.heartbeat = val;
    return fields;
  }

  public static function encodeConnectionTune(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(20 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(655390);
    val = fields.channelMax;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"channelMax\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.frameMax;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"frameMax\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt32(val);
    val = fields.heartbeat;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"heartbeat\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeConnectionOpen(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {virtualHost: null,capabilities: null,insist: null,};
    buffer.bigEndian = true;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.virtualHost = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.capabilities = val;
    val = bits.readBit();
    fields.insist = val;
    return fields;
  }

  public static function encodeConnectionOpen(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.virtualHost;
    if (val == null) {
      val = "/";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"virtualHost\" is the wrong type; must be a string (up to 255 chars)");
    }
    var virtualHost_len:Int = cast(val, String).length;
    varyingSize += virtualHost_len;
    val = fields.capabilities;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"capabilities\" is the wrong type; must be a string (up to 255 chars)");
    }
    var capabilities_len:Int = cast(val, String).length;
    varyingSize += capabilities_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(15 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(655400);
    val = fields.virtualHost;
    if (val == null) val = "/";
    output.writeByte(virtualHost_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.capabilities;
    if (val == null) val = "";
    output.writeByte(capabilities_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.insist;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"insist\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    output.writeByte(bits);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeBasicGet(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {ticket: null,queue: null,noAck: null,};
    buffer.bigEndian = true;
    val = buffer.readInt16();
    fields.ticket = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.queue = val;
    val = bits.readBit();
    fields.noAck = val;
    return fields;
  }

  public static function encodeBasicGet(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.queue;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"queue\" is the wrong type; must be a string (up to 255 chars)");
    }
    var queue_len:Int = cast(val, String).length;
    varyingSize += queue_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(16 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3932230);
    val = fields.ticket;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"ticket\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.queue;
    if (val == null) val = "";
    output.writeByte(queue_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.noAck;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"noAck\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    output.writeByte(bits);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeBasicGetEmpty(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {clusterId: null,};
    buffer.bigEndian = true;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.clusterId = val;
    return fields;
  }

  public static function encodeBasicGetEmpty(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.clusterId;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"clusterId\" is the wrong type; must be a string (up to 255 chars)");
    }
    var clusterId_len:Int = cast(val, String).length;
    varyingSize += clusterId_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(13 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3932232);
    val = fields.clusterId;
    if (val == null) val = "";
    output.writeByte(clusterId_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeExchangeDeleteOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {};
    buffer.bigEndian = true;
    return fields;
  }

  public static function encodeExchangeDeleteOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(12 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(2621461);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeConnectionStartOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {clientProperties: null,mechanism: null,response: null,locale: null,};
    buffer.bigEndian = true;
    len = buffer.readInt32();
    b = Bytes.alloc(len);
    buffer.readBytes(b, 0, len);
    val = Codec.DecodeFields(b);
    fields.clientProperties = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.mechanism = val;
    len = buffer.readInt32();
    val = buffer.readString(len);
    fields.response = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.locale = val;
    return fields;
  }

  public static function encodeConnectionStartOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.clientProperties;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"clientProperties\"");
    } else if (!(Std.isOfType(val, Dynamic))) {
      throw new haxe.Exception("Field \"clientProperties\" is the wrong type; must be a Dynamic");
    }
    // ensure big endian and flush previous content
    SCRATCH.bigEndian = true;
    SCRATCH.flush();
    // encode table
    var clientProperties_encoded:Bytes = Codec.EncodeTable(SCRATCH, val);
    varyingSize += clientProperties_encoded.length;
    val = fields.mechanism;
    if (val == null) {
      val = "PLAIN";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"mechanism\" is the wrong type; must be a string (up to 255 chars)");
    }
    var mechanism_len:Int = cast(val, String).length;
    varyingSize += mechanism_len;
    val = fields.response;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"response\"");
    } else if (!(Std.isOfType(val, String))) {
      throw new haxe.Exception("Field \"response\" is the wrong type; must be a String");
    }
    varyingSize += val.length;
    val = fields.locale;
    if (val == null) {
      val = "en_US";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"locale\" is the wrong type; must be a string (up to 255 chars)");
    }
    var locale_len:Int = cast(val, String).length;
    varyingSize += locale_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(18 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(655371);
    output.writeBytes(clientProperties_encoded, 0, clientProperties_encoded.length);
    val = fields.mechanism;
    if (val == null) val = "PLAIN";
    output.writeByte(mechanism_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.response;
    if (val == null) val = null;
    len = cast(val, String).length;
    output.writeInt32(len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.locale;
    if (val == null) val = "en_US";
    output.writeByte(locale_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeQueueDeclareOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {queue: null,messageCount: null,consumerCount: null,};
    buffer.bigEndian = true;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.queue = val;
    val = buffer.readInt32();
    fields.messageCount = val;
    val = buffer.readInt32();
    fields.consumerCount = val;
    return fields;
  }

  public static function encodeQueueDeclareOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.queue;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"queue\"");
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"queue\" is the wrong type; must be a string (up to 255 chars)");
    }
    var queue_len:Int = cast(val, String).length;
    varyingSize += queue_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(21 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3276811);
    val = fields.queue;
    if (val == null) val = null;
    output.writeByte(queue_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.messageCount;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"messageCount\"");
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"messageCount\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt32(val);
    val = fields.consumerCount;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"consumerCount\"");
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"consumerCount\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt32(val);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeConnectionSecureOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {response: null,};
    buffer.bigEndian = true;
    len = buffer.readInt32();
    val = buffer.readString(len);
    fields.response = val;
    return fields;
  }

  public static function encodeConnectionSecureOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.response;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"response\"");
    } else if (!(Std.isOfType(val, String))) {
      throw new haxe.Exception("Field \"response\" is the wrong type; must be a String");
    }
    varyingSize += val.length;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(16 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(655381);
    val = fields.response;
    if (val == null) val = null;
    len = cast(val, String).length;
    output.writeInt32(len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeExchangeDeclareOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {};
    buffer.bigEndian = true;
    return fields;
  }

  public static function encodeExchangeDeclareOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(12 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(2621451);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeExchangeDeclare(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {ticket: null,exchange: null,type: null,passive: null,durable: null,autoDelete: null,internal: null,nowait: null,arguments: null,};
    buffer.bigEndian = true;
    val = buffer.readInt16();
    fields.ticket = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.exchange = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.type = val;
    val = bits.readBit();
    fields.passive = val;
    val = bits.readBit();
    fields.durable = val;
    val = bits.readBit();
    fields.autoDelete = val;
    val = bits.readBit();
    fields.internal = val;
    val = bits.readBit();
    fields.nowait = val;
    // read full byte before starting with next
    bits.readBit();
    bits.readBit();
    bits.readBit();
    len = buffer.readInt32();
    b = Bytes.alloc(len);
    buffer.readBytes(b, 0, len);
    val = Codec.DecodeFields(b);
    fields.arguments = val;
    return fields;
  }

  public static function encodeExchangeDeclare(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.exchange;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"exchange\"");
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"exchange\" is the wrong type; must be a string (up to 255 chars)");
    }
    var exchange_len:Int = cast(val, String).length;
    varyingSize += exchange_len;
    val = fields.type;
    if (val == null) {
      val = "direct";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"type\" is the wrong type; must be a string (up to 255 chars)");
    }
    var type_len:Int = cast(val, String).length;
    varyingSize += type_len;
    val = fields.arguments;
    if (val == null) {
      val = {};
    } else if (!(Std.isOfType(val, Dynamic))) {
      throw new haxe.Exception("Field \"arguments\" is the wrong type; must be a Dynamic");
    }
    // ensure big endian and flush previous content
    SCRATCH.bigEndian = true;
    SCRATCH.flush();
    // encode table
    var arguments_encoded:Bytes = Codec.EncodeTable(SCRATCH, val);
    varyingSize += arguments_encoded.length;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(17 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(2621450);
    val = fields.ticket;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"ticket\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.exchange;
    if (val == null) val = null;
    output.writeByte(exchange_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.type;
    if (val == null) val = "direct";
    output.writeByte(type_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.passive;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"passive\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    val = fields.durable;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"durable\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 2;
    }
    val = fields.autoDelete;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"autoDelete\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 4;
    }
    val = fields.internal;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"internal\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 8;
    }
    val = fields.nowait;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"nowait\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 16;
    }
    output.writeByte(bits);
    output.writeBytes(arguments_encoded, 0, arguments_encoded.length);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeBasicGetOk(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {deliveryTag: null,redelivered: null,exchange: null,routingKey: null,messageCount: null,};
    buffer.bigEndian = true;
    val = buffer.readInt64();
    fields.deliveryTag = val;
    val = bits.readBit();
    fields.redelivered = val;
    // read full byte before starting with next
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.exchange = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.routingKey = val;
    val = buffer.readInt32();
    fields.messageCount = val;
    return fields;
  }

  public static function encodeBasicGetOk(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.exchange;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"exchange\"");
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"exchange\" is the wrong type; must be a string (up to 255 chars)");
    }
    var exchange_len:Int = cast(val, String).length;
    varyingSize += exchange_len;
    val = fields.routingKey;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"routingKey\"");
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"routingKey\" is the wrong type; must be a string (up to 255 chars)");
    }
    var routingKey_len:Int = cast(val, String).length;
    varyingSize += routingKey_len;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(19 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3932231);
    val = fields.deliveryTag;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"deliveryTag\"");
    } else if (!(Int64.isInt64(val))) {
      throw new haxe.Exception("Field \"deliveryTag\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt64(val);
    val = fields.redelivered;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"redelivered\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    output.writeByte(bits);
    val = fields.exchange;
    if (val == null) val = null;
    output.writeByte(exchange_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.routingKey;
    if (val == null) val = null;
    output.writeByte(routingKey_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.messageCount;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"messageCount\"");
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"messageCount\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt32(val);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeQueueBind(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {ticket: null,queue: null,exchange: null,routingKey: null,nowait: null,arguments: null,};
    buffer.bigEndian = true;
    val = buffer.readInt16();
    fields.ticket = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.queue = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.exchange = val;
    len = buffer.readInt8();
    val = buffer.readString(len);
    fields.routingKey = val;
    val = bits.readBit();
    fields.nowait = val;
    // read full byte before starting with next
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    bits.readBit();
    len = buffer.readInt32();
    b = Bytes.alloc(len);
    buffer.readBytes(b, 0, len);
    val = Codec.DecodeFields(b);
    fields.arguments = val;
    return fields;
  }

  public static function encodeQueueBind(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.queue;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"queue\" is the wrong type; must be a string (up to 255 chars)");
    }
    var queue_len:Int = cast(val, String).length;
    varyingSize += queue_len;
    val = fields.exchange;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"exchange\"");
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"exchange\" is the wrong type; must be a string (up to 255 chars)");
    }
    var exchange_len:Int = cast(val, String).length;
    varyingSize += exchange_len;
    val = fields.routingKey;
    if (val == null) {
      val = "";
    } else if (!(Std.isOfType(val, String) && cast(val, String).length < 256)) {
      throw new haxe.Exception("Field \"routingKey\" is the wrong type; must be a string (up to 255 chars)");
    }
    var routingKey_len:Int = cast(val, String).length;
    varyingSize += routingKey_len;
    val = fields.arguments;
    if (val == null) {
      val = {};
    } else if (!(Std.isOfType(val, Dynamic))) {
      throw new haxe.Exception("Field \"arguments\" is the wrong type; must be a Dynamic");
    }
    // ensure big endian and flush previous content
    SCRATCH.bigEndian = true;
    SCRATCH.flush();
    // encode table
    var arguments_encoded:Bytes = Codec.EncodeTable(SCRATCH, val);
    varyingSize += arguments_encoded.length;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(18 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(3276820);
    val = fields.ticket;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"ticket\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeInt16(val);
    val = fields.queue;
    if (val == null) val = "";
    output.writeByte(queue_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.exchange;
    if (val == null) val = null;
    output.writeByte(exchange_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.routingKey;
    if (val == null) val = "";
    output.writeByte(routingKey_len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.nowait;
    if (val == null) {
      val = false;
    } else if (!(Std.isOfType(val, Bool))) {
      throw new haxe.Exception("Field \"nowait\" is the wrong type; must be booleany");
    }
    if (cast(val, Bool)) {
      bits += 1;
    }
    output.writeByte(bits);
    output.writeBytes(arguments_encoded, 0, arguments_encoded.length);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeConnectionStart(buffer:BytesInput):Dynamic {
    var val:Dynamic;
    var len:Int = 0;
    var b:Bytes;
    var bits:BitsInput = new BitsInput(buffer);
    var fields:Dynamic = {versionMajor: null,versionMinor: null,serverProperties: null,mechanisms: null,locales: null,};
    buffer.bigEndian = true;
    val = buffer.readByte();
    fields.versionMajor = val;
    val = buffer.readByte();
    fields.versionMinor = val;
    len = buffer.readInt32();
    b = Bytes.alloc(len);
    buffer.readBytes(b, 0, len);
    val = Codec.DecodeFields(b);
    fields.serverProperties = val;
    len = buffer.readInt32();
    val = buffer.readString(len);
    fields.mechanisms = val;
    len = buffer.readInt32();
    val = buffer.readString(len);
    fields.locales = val;
    return fields;
  }

  public static function encodeConnectionStart(channel:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var val:Dynamic = null;
    var bits:Int = 0;
    var varyingSize:Int = 0;
    var len:Int;
    var offset:Int = 0;
    val = fields.serverProperties;
    if (val == null) {
      throw new haxe.Exception("Missing value for mandatory field \"serverProperties\"");
    } else if (!(Std.isOfType(val, Dynamic))) {
      throw new haxe.Exception("Field \"serverProperties\" is the wrong type; must be a Dynamic");
    }
    // ensure big endian and flush previous content
    SCRATCH.bigEndian = true;
    SCRATCH.flush();
    // encode table
    var serverProperties_encoded:Bytes = Codec.EncodeTable(SCRATCH, val);
    varyingSize += serverProperties_encoded.length;
    val = fields.mechanisms;
    if (val == null) {
      val = "PLAIN";
    } else if (!(Std.isOfType(val, String))) {
      throw new haxe.Exception("Field \"mechanisms\" is the wrong type; must be a String");
    }
    varyingSize += val.length;
    val = fields.locales;
    if (val == null) {
      val = "en_US";
    } else if (!(Std.isOfType(val, String))) {
      throw new haxe.Exception("Field \"locales\" is the wrong type; must be a String");
    }
    varyingSize += val.length;
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(22 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_METHOD);
    output.writeInt16(channel);
    output.writeInt32(0); // space for final size at the end
    output.writeInt32(655370);
    val = fields.versionMajor;
    if (val == null) {
      val = 0;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"versionMajor\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeByte(val);
    val = fields.versionMinor;
    if (val == null) {
      val = 9;
    } else if (!(Std.isOfType(val, Int))) {
      throw new haxe.Exception("Field \"versionMinor\" is the wrong type; must be a number (but not NaN)");
    }
    output.writeByte(val);
    output.writeBytes(serverProperties_encoded, 0, serverProperties_encoded.length);
    val = fields.mechanisms;
    if (val == null) val = "PLAIN";
    len = cast(val, String).length;
    output.writeInt32(len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    val = fields.locales;
    if (val == null) val = "en_US";
    len = cast(val, String).length;
    output.writeInt32(len);
    output.writeString(val, haxe.io.Encoding.UTF8);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function encodeBasicProperties(channel:Int, size:Int, fields:Dynamic):Bytes {
    var offset:Int = 0;
    var flags:Int = 0;
    var val:Dynamic;
    var len:Int;
    var varyingSize:Int = 0;
    val = fields.contentType;
    if (val != null) {
      if (Std.isOfType(val, String) && cast(val, String).length < 256) {
    var contentType_len:Int = cast(val, String).length;
        varyingSize += 1;
        varyingSize += contentType_len;
      } else {
        throw new haxe.Exception('Field "contentType" is the wrong type; must be a string (up to 255 chars)');
      }
    }
    val = fields.contentEncoding;
    if (val != null) {
      if (Std.isOfType(val, String) && cast(val, String).length < 256) {
    var contentEncoding_len:Int = cast(val, String).length;
        varyingSize += 1;
        varyingSize += contentEncoding_len;
      } else {
        throw new haxe.Exception('Field "contentEncoding" is the wrong type; must be a string (up to 255 chars)');
      }
    }
    val = fields.headers;
    var headers_encoded:Bytes = null;
    if (val != null) {
      if (Std.isOfType(val, Dynamic)) {
    // ensure big endian and flush previous content
    SCRATCH.bigEndian = true;
    SCRATCH.flush();
    // encode table
    headers_encoded = Codec.EncodeTable(SCRATCH, val);
        varyingSize += headers_encoded.length;
      } else {
        throw new haxe.Exception('Field "headers" is the wrong type; must be a Dynamic');
      }
    }
    val = fields.deliveryMode;
    if (val != null) {
      if (Std.isOfType(val, Int)) {
        varyingSize += 1;
      } else {
        throw new haxe.Exception('Field "deliveryMode" is the wrong type; must be a number (but not NaN)');
      }
    }
    val = fields.priority;
    if (val != null) {
      if (Std.isOfType(val, Int)) {
        varyingSize += 1;
      } else {
        throw new haxe.Exception('Field "priority" is the wrong type; must be a number (but not NaN)');
      }
    }
    val = fields.correlationId;
    if (val != null) {
      if (Std.isOfType(val, String) && cast(val, String).length < 256) {
    var correlationId_len:Int = cast(val, String).length;
        varyingSize += 1;
        varyingSize += correlationId_len;
      } else {
        throw new haxe.Exception('Field "correlationId" is the wrong type; must be a string (up to 255 chars)');
      }
    }
    val = fields.replyTo;
    if (val != null) {
      if (Std.isOfType(val, String) && cast(val, String).length < 256) {
    var replyTo_len:Int = cast(val, String).length;
        varyingSize += 1;
        varyingSize += replyTo_len;
      } else {
        throw new haxe.Exception('Field "replyTo" is the wrong type; must be a string (up to 255 chars)');
      }
    }
    val = fields.expiration;
    if (val != null) {
      if (Std.isOfType(val, String) && cast(val, String).length < 256) {
    var expiration_len:Int = cast(val, String).length;
        varyingSize += 1;
        varyingSize += expiration_len;
      } else {
        throw new haxe.Exception('Field "expiration" is the wrong type; must be a string (up to 255 chars)');
      }
    }
    val = fields.messageId;
    if (val != null) {
      if (Std.isOfType(val, String) && cast(val, String).length < 256) {
    var messageId_len:Int = cast(val, String).length;
        varyingSize += 1;
        varyingSize += messageId_len;
      } else {
        throw new haxe.Exception('Field "messageId" is the wrong type; must be a string (up to 255 chars)');
      }
    }
    val = fields.timestamp;
    if (val != null) {
      if (Int64.isInt64(val)) {
        varyingSize += 8;
      } else {
        throw new haxe.Exception('Field "timestamp" is the wrong type; must be a number (but not NaN)');
      }
    }
    val = fields.type;
    if (val != null) {
      if (Std.isOfType(val, String) && cast(val, String).length < 256) {
    var type_len:Int = cast(val, String).length;
        varyingSize += 1;
        varyingSize += type_len;
      } else {
        throw new haxe.Exception('Field "type" is the wrong type; must be a string (up to 255 chars)');
      }
    }
    val = fields.userId;
    if (val != null) {
      if (Std.isOfType(val, String) && cast(val, String).length < 256) {
    var userId_len:Int = cast(val, String).length;
        varyingSize += 1;
        varyingSize += userId_len;
      } else {
        throw new haxe.Exception('Field "userId" is the wrong type; must be a string (up to 255 chars)');
      }
    }
    val = fields.appId;
    if (val != null) {
      if (Std.isOfType(val, String) && cast(val, String).length < 256) {
    var appId_len:Int = cast(val, String).length;
        varyingSize += 1;
        varyingSize += appId_len;
      } else {
        throw new haxe.Exception('Field "appId" is the wrong type; must be a string (up to 255 chars)');
      }
    }
    val = fields.clusterId;
    if (val != null) {
      if (Std.isOfType(val, String) && cast(val, String).length < 256) {
    var clusterId_len:Int = cast(val, String).length;
        varyingSize += 1;
        varyingSize += clusterId_len;
      } else {
        throw new haxe.Exception('Field "clusterId" is the wrong type; must be a string (up to 255 chars)');
      }
    }
    var output:BytesOutput = new BytesOutput();
    output.bigEndian = true;
    output.prepare(22 + varyingSize);
    output.writeByte(amqp.helper.protocol.Constant.FRAME_HEADER);
    output.writeInt16(channel);
    output.writeInt32(0); // space for size
    output.writeInt32(3932160);
    output.writeInt64(size);
    output.writeInt16(0); // space for flags
    val = fields.contentType;
    if (val != null) {
      flags += 32768;
      output.writeByte(cast(val, String).length);
      output.writeString(cast(val, String), haxe.io.Encoding.UTF8);
    }
    val = fields.contentEncoding;
    if (val != null) {
      flags += 16384;
      output.writeByte(cast(val, String).length);
      output.writeString(cast(val, String), haxe.io.Encoding.UTF8);
    }
    val = fields.headers;
    if (val != null) {
      flags += 8192;
      output.writeBytes(headers_encoded, 0, headers_encoded.length);
    }
    val = fields.deliveryMode;
    if (val != null) {
      flags += 4096;
      output.writeByte(val);
    }
    val = fields.priority;
    if (val != null) {
      flags += 2048;
      output.writeByte(val);
    }
    val = fields.correlationId;
    if (val != null) {
      flags += 1024;
      output.writeByte(cast(val, String).length);
      output.writeString(cast(val, String), haxe.io.Encoding.UTF8);
    }
    val = fields.replyTo;
    if (val != null) {
      flags += 512;
      output.writeByte(cast(val, String).length);
      output.writeString(cast(val, String), haxe.io.Encoding.UTF8);
    }
    val = fields.expiration;
    if (val != null) {
      flags += 256;
      output.writeByte(cast(val, String).length);
      output.writeString(cast(val, String), haxe.io.Encoding.UTF8);
    }
    val = fields.messageId;
    if (val != null) {
      flags += 128;
      output.writeByte(cast(val, String).length);
      output.writeString(cast(val, String), haxe.io.Encoding.UTF8);
    }
    val = fields.timestamp;
    if (val != null) {
      flags += 64;
      output.writeInt64(val);
    }
    val = fields.type;
    if (val != null) {
      flags += 32;
      output.writeByte(cast(val, String).length);
      output.writeString(cast(val, String), haxe.io.Encoding.UTF8);
    }
    val = fields.userId;
    if (val != null) {
      flags += 16;
      output.writeByte(cast(val, String).length);
      output.writeString(cast(val, String), haxe.io.Encoding.UTF8);
    }
    val = fields.appId;
    if (val != null) {
      flags += 8;
      output.writeByte(cast(val, String).length);
      output.writeString(cast(val, String), haxe.io.Encoding.UTF8);
    }
    val = fields.clusterId;
    if (val != null) {
      flags += 4;
      output.writeByte(cast(val, String).length);
      output.writeString(cast(val, String), haxe.io.Encoding.UTF8);
    }
    output.writeByte(amqp.helper.protocol.Constant.FRAME_END);
    // hacky push in size
    var sizeOutput:BytesOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt32(output.length - 8);
    var bytes:haxe.io.Bytes = output.getBytes();
    bytes.blit(3, sizeOutput.getBytes(), 0, 4);
    // hacky push in flags
    sizeOutput = new BytesOutput();
    sizeOutput.bigEndian = true;
    sizeOutput.writeInt16(flags);
    bytes.blit(19, sizeOutput.getBytes(), 0, 2);
    return new Bytes(bytes.getData().length, bytes.getData());
  }

  public static function decodeBasicProperties(buffer:BytesInput):Dynamic {
    var flags:Int;
    var val:Dynamic;
    var len:Int;

    buffer.bigEndian = true;
    flags = buffer.readUInt16();
    if (flags == 0) {
      return {};
    }

    var fields:Dynamic = {contentType: null,contentEncoding: null,headers: null,deliveryMode: null,priority: null,correlationId: null,replyTo: null,expiration: null,messageId: null,timestamp: null,type: null,userId: null,appId: null,clusterId: null,};
    if (flags & 32768 == 32768) {
      len = buffer.readInt8();
      val = buffer.readString(len);
      fields.contentType = val;
    }
    if (flags & 16384 == 16384) {
      len = buffer.readInt8();
      val = buffer.readString(len);
      fields.contentEncoding = val;
    }
    if (flags & 8192 == 8192) {
      len = buffer.readInt32();
      var buf:Bytes = Bytes.alloc(len);
      buffer.readBytes(buf, 0, len);
      val = Codec.DecodeFields(Bytes.ofData(buf.getData()));
      fields.headers = val;
    }
    if (flags & 4096 == 4096) {
      val = buffer.readInt8();
      fields.deliveryMode = val;
    }
    if (flags & 2048 == 2048) {
      val = buffer.readInt8();
      fields.priority = val;
    }
    if (flags & 1024 == 1024) {
      len = buffer.readInt8();
      val = buffer.readString(len);
      fields.correlationId = val;
    }
    if (flags & 512 == 512) {
      len = buffer.readInt8();
      val = buffer.readString(len);
      fields.replyTo = val;
    }
    if (flags & 256 == 256) {
      len = buffer.readInt8();
      val = buffer.readString(len);
      fields.expiration = val;
    }
    if (flags & 128 == 128) {
      len = buffer.readInt8();
      val = buffer.readString(len);
      fields.messageId = val;
    }
    if (flags & 64 == 64) {
      val = buffer.readInt64();
      fields.timestamp = val;
    }
    if (flags & 32 == 32) {
      len = buffer.readInt8();
      val = buffer.readString(len);
      fields.type = val;
    }
    if (flags & 16 == 16) {
      len = buffer.readInt8();
      val = buffer.readString(len);
      fields.userId = val;
    }
    if (flags & 8 == 8) {
      len = buffer.readInt8();
      val = buffer.readString(len);
      fields.appId = val;
    }
    if (flags & 4 == 4) {
      len = buffer.readInt8();
      val = buffer.readString(len);
      fields.clusterId = val;
    }
    return fields;
  }

  public static function decode(id:Int, buf:BytesInput): Dynamic {
    switch(id) {
      case 3932181: return decodeBasicConsumeOk(buf);
      case 3932190: return decodeBasicCancel(buf);
      case 3932270: return decodeBasicRecover(buf);
      case 2621480: return decodeExchangeUnbind(buf);
      case 5898260: return decodeTxCommit(buf);
      case 3932200: return decodeBasicPublish(buf);
      case 3276831: return decodeQueuePurgeOk(buf);
      case 3276830: return decodeQueuePurge(buf);
      case 5898261: return decodeTxCommitOk(buf);
      case 1966091: return decodeAccessRequestOk(buf);
      case 2621491: return decodeExchangeUnbindOk(buf);
      case 1310740: return decodeChannelFlow(buf);
      case 655391: return decodeConnectionTuneOk(buf);
      case 5898271: return decodeTxRollbackOk(buf);
      case 655380: return decodeConnectionSecure(buf);
      case 3932271: return decodeBasicRecoverOk(buf);
      case 2621471: return decodeExchangeBindOk(buf);
      case 5898251: return decodeTxSelectOk(buf);
      case 655421: return decodeConnectionUnblocked(buf);
      case 3932260: return decodeBasicRecoverAsync(buf);
      case 2621470: return decodeExchangeBind(buf);
      case 5570571: return decodeConfirmSelectOk(buf);
      case 3932171: return decodeBasicQosOk(buf);
      case 2621460: return decodeExchangeDelete(buf);
      case 5898270: return decodeTxRollback(buf);
      case 5570570: return decodeConfirmSelect(buf);
      case 1310741: return decodeChannelFlowOk(buf);
      case 3932170: return decodeBasicQos(buf);
      case 3276840: return decodeQueueDelete(buf);
      case 1310731: return decodeChannelOpenOk(buf);
      case 3932191: return decodeBasicCancelOk(buf);
      case 3932250: return decodeBasicReject(buf);
      case 655411: return decodeConnectionCloseOk(buf);
      case 3276841: return decodeQueueDeleteOk(buf);
      case 1310760: return decodeChannelClose(buf);
      case 3932220: return decodeBasicDeliver(buf);
      case 1310730: return decodeChannelOpen(buf);
      case 3932240: return decodeBasicAck(buf);
      case 655420: return decodeConnectionBlocked(buf);
      case 1966090: return decodeAccessRequest(buf);
      case 3276810: return decodeQueueDeclare(buf);
      case 3276850: return decodeQueueUnbind(buf);
      case 1310761: return decodeChannelCloseOk(buf);
      case 3932180: return decodeBasicConsume(buf);
      case 3276851: return decodeQueueUnbindOk(buf);
      case 3932280: return decodeBasicNack(buf);
      case 655401: return decodeConnectionOpenOk(buf);
      case 3276821: return decodeQueueBindOk(buf);
      case 5898250: return decodeTxSelect(buf);
      case 3932210: return decodeBasicReturn(buf);
      case 655410: return decodeConnectionClose(buf);
      case 655390: return decodeConnectionTune(buf);
      case 655400: return decodeConnectionOpen(buf);
      case 3932230: return decodeBasicGet(buf);
      case 3932232: return decodeBasicGetEmpty(buf);
      case 2621461: return decodeExchangeDeleteOk(buf);
      case 655371: return decodeConnectionStartOk(buf);
      case 3276811: return decodeQueueDeclareOk(buf);
      case 655381: return decodeConnectionSecureOk(buf);
      case 2621451: return decodeExchangeDeclareOk(buf);
      case 2621450: return decodeExchangeDeclare(buf);
      case 3932231: return decodeBasicGetOk(buf);
      case 3276820: return decodeQueueBind(buf);
      case 655370: return decodeConnectionStart(buf);
      case 60: return decodeBasicProperties(buf);
      default: throw new haxe.Exception('Unknown class/method id $id');
    }
  }
  public static function encodeMethod(id:Int, channel:Dynamic, fields:Dynamic):Bytes {
    switch(id) {
      case 3932181: return encodeBasicConsumeOk(channel, fields);
      case 3932190: return encodeBasicCancel(channel, fields);
      case 3932270: return encodeBasicRecover(channel, fields);
      case 2621480: return encodeExchangeUnbind(channel, fields);
      case 5898260: return encodeTxCommit(channel, fields);
      case 3932200: return encodeBasicPublish(channel, fields);
      case 3276831: return encodeQueuePurgeOk(channel, fields);
      case 3276830: return encodeQueuePurge(channel, fields);
      case 5898261: return encodeTxCommitOk(channel, fields);
      case 1966091: return encodeAccessRequestOk(channel, fields);
      case 2621491: return encodeExchangeUnbindOk(channel, fields);
      case 1310740: return encodeChannelFlow(channel, fields);
      case 655391: return encodeConnectionTuneOk(channel, fields);
      case 5898271: return encodeTxRollbackOk(channel, fields);
      case 655380: return encodeConnectionSecure(channel, fields);
      case 3932271: return encodeBasicRecoverOk(channel, fields);
      case 2621471: return encodeExchangeBindOk(channel, fields);
      case 5898251: return encodeTxSelectOk(channel, fields);
      case 655421: return encodeConnectionUnblocked(channel, fields);
      case 3932260: return encodeBasicRecoverAsync(channel, fields);
      case 2621470: return encodeExchangeBind(channel, fields);
      case 5570571: return encodeConfirmSelectOk(channel, fields);
      case 3932171: return encodeBasicQosOk(channel, fields);
      case 2621460: return encodeExchangeDelete(channel, fields);
      case 5898270: return encodeTxRollback(channel, fields);
      case 5570570: return encodeConfirmSelect(channel, fields);
      case 1310741: return encodeChannelFlowOk(channel, fields);
      case 3932170: return encodeBasicQos(channel, fields);
      case 3276840: return encodeQueueDelete(channel, fields);
      case 1310731: return encodeChannelOpenOk(channel, fields);
      case 3932191: return encodeBasicCancelOk(channel, fields);
      case 3932250: return encodeBasicReject(channel, fields);
      case 655411: return encodeConnectionCloseOk(channel, fields);
      case 3276841: return encodeQueueDeleteOk(channel, fields);
      case 1310760: return encodeChannelClose(channel, fields);
      case 3932220: return encodeBasicDeliver(channel, fields);
      case 1310730: return encodeChannelOpen(channel, fields);
      case 3932240: return encodeBasicAck(channel, fields);
      case 655420: return encodeConnectionBlocked(channel, fields);
      case 1966090: return encodeAccessRequest(channel, fields);
      case 3276810: return encodeQueueDeclare(channel, fields);
      case 3276850: return encodeQueueUnbind(channel, fields);
      case 1310761: return encodeChannelCloseOk(channel, fields);
      case 3932180: return encodeBasicConsume(channel, fields);
      case 3276851: return encodeQueueUnbindOk(channel, fields);
      case 3932280: return encodeBasicNack(channel, fields);
      case 655401: return encodeConnectionOpenOk(channel, fields);
      case 3276821: return encodeQueueBindOk(channel, fields);
      case 5898250: return encodeTxSelect(channel, fields);
      case 3932210: return encodeBasicReturn(channel, fields);
      case 655410: return encodeConnectionClose(channel, fields);
      case 655390: return encodeConnectionTune(channel, fields);
      case 655400: return encodeConnectionOpen(channel, fields);
      case 3932230: return encodeBasicGet(channel, fields);
      case 3932232: return encodeBasicGetEmpty(channel, fields);
      case 2621461: return encodeExchangeDeleteOk(channel, fields);
      case 655371: return encodeConnectionStartOk(channel, fields);
      case 3276811: return encodeQueueDeclareOk(channel, fields);
      case 655381: return encodeConnectionSecureOk(channel, fields);
      case 2621451: return encodeExchangeDeclareOk(channel, fields);
      case 2621450: return encodeExchangeDeclare(channel, fields);
      case 3932231: return encodeBasicGetOk(channel, fields);
      case 3276820: return encodeQueueBind(channel, fields);
      case 655370: return encodeConnectionStart(channel, fields);
      default: throw new haxe.Exception('Unknown class/method id $id');
    }
  }
  public static function encodeProperties(id:Int, channel:Dynamic, size:Dynamic, fields:Dynamic):Bytes {
    switch (id) {
      case 60: return encodeBasicProperties(channel, size, fields);
      default: throw new haxe.Exception('Unknown class/properties id $id');
    }
  }
  public static function info(id:Int):Dynamic {
    switch (id) {
      case 3932181: return methodInfoBasicConsumeOk;
      case 3932190: return methodInfoBasicCancel;
      case 3932270: return methodInfoBasicRecover;
      case 2621480: return methodInfoExchangeUnbind;
      case 5898260: return methodInfoTxCommit;
      case 3932200: return methodInfoBasicPublish;
      case 3276831: return methodInfoQueuePurgeOk;
      case 3276830: return methodInfoQueuePurge;
      case 5898261: return methodInfoTxCommitOk;
      case 1966091: return methodInfoAccessRequestOk;
      case 2621491: return methodInfoExchangeUnbindOk;
      case 1310740: return methodInfoChannelFlow;
      case 655391: return methodInfoConnectionTuneOk;
      case 5898271: return methodInfoTxRollbackOk;
      case 655380: return methodInfoConnectionSecure;
      case 3932271: return methodInfoBasicRecoverOk;
      case 2621471: return methodInfoExchangeBindOk;
      case 5898251: return methodInfoTxSelectOk;
      case 655421: return methodInfoConnectionUnblocked;
      case 3932260: return methodInfoBasicRecoverAsync;
      case 2621470: return methodInfoExchangeBind;
      case 5570571: return methodInfoConfirmSelectOk;
      case 3932171: return methodInfoBasicQosOk;
      case 2621460: return methodInfoExchangeDelete;
      case 5898270: return methodInfoTxRollback;
      case 5570570: return methodInfoConfirmSelect;
      case 1310741: return methodInfoChannelFlowOk;
      case 3932170: return methodInfoBasicQos;
      case 3276840: return methodInfoQueueDelete;
      case 1310731: return methodInfoChannelOpenOk;
      case 3932191: return methodInfoBasicCancelOk;
      case 3932250: return methodInfoBasicReject;
      case 655411: return methodInfoConnectionCloseOk;
      case 3276841: return methodInfoQueueDeleteOk;
      case 1310760: return methodInfoChannelClose;
      case 3932220: return methodInfoBasicDeliver;
      case 1310730: return methodInfoChannelOpen;
      case 3932240: return methodInfoBasicAck;
      case 655420: return methodInfoConnectionBlocked;
      case 1966090: return methodInfoAccessRequest;
      case 3276810: return methodInfoQueueDeclare;
      case 3276850: return methodInfoQueueUnbind;
      case 1310761: return methodInfoChannelCloseOk;
      case 3932180: return methodInfoBasicConsume;
      case 3276851: return methodInfoQueueUnbindOk;
      case 3932280: return methodInfoBasicNack;
      case 655401: return methodInfoConnectionOpenOk;
      case 3276821: return methodInfoQueueBindOk;
      case 5898250: return methodInfoTxSelect;
      case 3932210: return methodInfoBasicReturn;
      case 655410: return methodInfoConnectionClose;
      case 655390: return methodInfoConnectionTune;
      case 655400: return methodInfoConnectionOpen;
      case 3932230: return methodInfoBasicGet;
      case 3932232: return methodInfoBasicGetEmpty;
      case 2621461: return methodInfoExchangeDeleteOk;
      case 655371: return methodInfoConnectionStartOk;
      case 3276811: return methodInfoQueueDeclareOk;
      case 655381: return methodInfoConnectionSecureOk;
      case 2621451: return methodInfoExchangeDeclareOk;
      case 2621450: return methodInfoExchangeDeclare;
      case 3932231: return methodInfoBasicGetOk;
      case 3276820: return methodInfoQueueBind;
      case 655370: return methodInfoConnectionStart;
      case 60: return propertiesInfoBasicProperties;
      default: throw new haxe.Exception('Unknown method/properties id $id');
    }
  }
}
